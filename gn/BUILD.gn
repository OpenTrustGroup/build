# Copyright 2016 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/clang/clang.gni")
import("//build/config/fuchsia/bootdata.gni")
import("//build/config/fuchsia/zircon.gni")
import("//build/gn/config.gni")
import("//build/gn/packages.gni")
import("//build/package.gni")

zircon_files =
    exec_script("//build/zircon/list_source_files.py", [], "list lines")

supporting_templates = [
  "//build/zircon/boards.mako",
  "//build/zircon/header.mako",
  "//build/zircon/host_tool.mako",
  "//build/zircon/main.mako",
  "//build/zircon/shared_library.mako",
  "//build/zircon/source_library.mako",
  "//build/zircon/static_library.mako",
  "//build/zircon/sysroot.mako",
]

exec_script("//build/zircon/create_gn_rules.py",
            [
              "--out",
              rebase_path("//zircon/public"),
              "--staging",
              rebase_path("$root_out_dir/zircon-gn"),
              "--zircon-user-build",
              rebase_path("//out/build-zircon/build-\${target_cpu}"),
              "--zircon-tool-build",
              rebase_path("//out/build-zircon"),
            ],
            "",
            zircon_files + supporting_templates)

import("//zircon/public/config/boards.gni")

# OpenTrustGroup specific configs
import("//build/otg/config.gni")

# Permit dependencies on testonly targets from packages.
testonly = true

finalize_manifests_extra = [
  "elfinfo.py",
  "manifest.py",
  "variant.py",
  "package_imports_resolver.py",
]

action("finalize_manifests") {
  visibility = [
    ":*",
    "//build/bootfs:*",
  ]

  packages_file = "$target_gen_dir/packages"
  system_manifest_file = "$target_gen_dir/system.bootfs.manifest"
  build_id_file = "$root_out_dir/ids.txt"

  _result = exec_script("process_build_packages.py",
                        [
                          "--targets-file",
                          rebase_path(packages_file),
                          "--system-manifest",
                          rebase_path(system_manifest_file),
                          "--packages",
                          fuchsia_packages,
                          "--build-root",
                          rebase_path(root_build_dir),
                        ],
                        "scope",
                        rebase_path(packages_imported))

  script = "finalize_manifests.py"
  inputs = finalize_manifests_extra

  depfile = "$root_out_dir/finalize_manifests.d"
  outputs = [
    final_boot_manifest,
    final_system_manifest,
    build_id_file,
  ]

  deps = _result.deps
  sources = []
  response_file_args = [
    "--depfile=" + rebase_path(depfile, root_build_dir),
    "--build-id-file=" + rebase_path(build_id_file, root_build_dir),
  ]

  # First the toolchain and Zircon "ulib" manifests are pure auxiliaries:
  # they just supply libraries that might satisfy dependencies.

  sources += toolchain_manifests
  foreach(manifest, toolchain_manifests) {
    manifest_cwd = get_path_info(rebase_path(manifest), "dir")
    response_file_args += [
      "--cwd=$manifest_cwd",
      "--manifest=" + rebase_path(manifest),
    ]
  }

  sources += zircon_aux_manifests
  foreach(manifest, zircon_aux_manifests) {
    manifest_cwd = get_path_info(rebase_path(manifest), "dir") + "/.."
    response_file_args += [
      "--cwd=$manifest_cwd",
      "--manifest=" + rebase_path(manifest),
    ]
  }

  # Next, everything that will go into the final /boot manifest.
  response_file_args += [
    "--output=" + rebase_path(final_boot_manifest, root_build_dir),
    "--groups=$zircon_boot_groups",
  ]
  sources += zircon_boot_manifests
  foreach(manifest, zircon_boot_manifests) {
    manifest_cwd = get_path_info(rebase_path(manifest), "dir") + "/.."
    response_file_args += [
      "--cwd=$manifest_cwd",
      "--manifest=" + rebase_path(manifest),
    ]
  }

  # All the manifests generated by this build are relative to root_build_dir.
  response_file_args += [
    "--cwd=.",
    "--groups=all",
  ]

  foreach(package, _result.packages) {
    package_manifest = "$root_build_dir/package/$package/boot_manifest"

    sources += [ package_manifest ]

    response_file_args += [ "--manifest=" + rebase_path(package_manifest, root_build_dir) ]
  }

  # Finally, everything that will go into the final /system manifest.
  response_file_args += [
    "--output=" + rebase_path(final_system_manifest, root_build_dir),
    "--groups=$zircon_system_groups",
  ]
  foreach(manifest, zircon_boot_manifests) {
    manifest_cwd = get_path_info(rebase_path(manifest), "dir") + "/.."
    response_file_args += [
      "--cwd=$manifest_cwd",
      "--manifest=" + rebase_path(manifest),
    ]
  }

  # All the manifests generated by this build are relative to root_build_dir.
  response_file_args += [
    "--cwd=.",
    "--groups=all",
  ]

  # TODO(mcgrathr,jamesr): When process_build_packages.py drops support for
  # package JSON files adding files directly, this can go away.
  # GN won't let us make it a source because it's in the build directory
  # but is written implicitly at gen time rather than by a proper action.
  # We're relying on the depfile to notice its changes.
  #sources += [ system_manifest_file ]
  response_file_args += [ "--manifest=" + rebase_path(system_manifest_file) ]

  foreach(package, _result.packages) {
    package_manifest = "$root_build_dir/package/$package/system_manifest"

    sources += [ package_manifest ]

    response_file_args += [ "--manifest=" + rebase_path(package_manifest, root_build_dir) ]
  }

  foreach(package, _result.packages) {
    package_manifest = "$root_build_dir/package/$package/archive_manifest"
    final_manifest = "$root_build_dir/package/$package/final_archive_manifest"

    sources += [ package_manifest ]

    outputs += [ final_manifest ]
    response_file_args += [
      "--standalone-output=" + rebase_path(final_manifest, root_build_dir),
      "--manifest=" + rebase_path(package_manifest, root_build_dir),
    ]
  }

  foreach(package, _result.packages) {
    package_manifest = "$root_build_dir/package/$package/package_manifest"
    final_manifest = "$root_build_dir/package/$package/final_package_manifest"

    sources += [ package_manifest ]

    outputs += [ final_manifest ]
    response_file_args += [
      "--standalone-output=" + rebase_path(final_manifest, root_build_dir),
      "--manifest=" + rebase_path(package_manifest, root_build_dir),
    ]
  }

  response_file_contents = response_file_args
  args = [ "@{{response_file_name}}" ]
}

action("pkgbuilds") {
  packages_file = "$target_gen_dir/packages"

  pm_label = "//garnet/go/src/pm:pm_bin($host_toolchain)"

  pm_out_dir = get_label_info(pm_label, "root_out_dir")
  pm_path = "$pm_out_dir/pm"

  amber_publish_label = "//garnet/go/src/amber:amber-publish($host_toolchain)"

  amber_publish_out_dir = get_label_info(amber_publish_label, "root_out_dir")
  amber_publish_path = "$amber_publish_out_dir/amber-publish"

  merkleroot_bin = "$zircon_tools_dir/merkleroot"

  package_signing_key = system_package_key

  deps = [
    ":finalize_manifests",

    # TODO(raggi): cleanup these files, they shouldn't be in the root_build_dir
    "//garnet/go/src/amber:amber-srv-keys",
    amber_publish_label,
    pm_label,
  ]
  inputs = [
    pm_path,
    amber_publish_path,
    package_signing_key,
    merkleroot_bin,
  ]

  # XXX(raggi): packages_file is an input, but it's made by gen.py
  sources = [
    "build_all_fuchsia_packages.py",
  ]

  outputs = [
    packages_blobs_manifest,
    pkgsvr_index,
    "$root_out_dir/amber-files/repository/targets.json",
  ]

  script = "//build/gn_run_binary.sh"

  # TODO(raggi): technically this script inputs/outputs these things
  # inputs += [
  #   package_json_file,
  #   final_package_manifest,
  # ]
  # outputs += [
  #   "$pkg_out_dir/meta.far",
  #   "$pkg_out_dir/meta.far.merkle",
  # ]
  args = [
    clang_prefix,
    rebase_path(sources[0]),
    "--package-list",
    rebase_path(packages_file),
    "--packages-dir",
    rebase_path(packages_dir),
    "--signing-key",
    rebase_path(package_signing_key),
    "--pm",
    rebase_path(pm_path),
    "--merkleroot",
    rebase_path(merkleroot_bin),
    "--blob-manifest",
    rebase_path(packages_blobs_manifest),
    "--pkgsvr-index",
    rebase_path(pkgsvr_index),
    "--amber-publish",
    rebase_path(amber_publish_path),
    "--amber-repo",

    # TODO(raggi): re-arrange and formalize these paths:
    rebase_path("$root_out_dir/amber-files"),
    "--amber-keys",
    rebase_path("$root_out_dir"),
    "--amber-package-list",
    rebase_path("$root_gen_dir/amber-package-list"),
    "--amber-blobs-manifest",
    rebase_path("$root_gen_dir/amber-blobs-manifest"),
  ]
}

action("system.pkg") {
  visibility = [ ":*" ]
  pm_label = "//garnet/go/src/pm:pm_bin($host_toolchain)"
  pkgsvr_label = "//garnet/go/src/pmd:pkgsvr_bin"
  deps = [
    ":finalize_manifests",
    ":pkgbuilds",
    pkgsvr_label,
    pm_label,
  ]

  pm_out_dir = get_label_info(pm_label, "root_out_dir")
  pkgsvr_out_dir = get_label_info(pkgsvr_label, "root_out_dir")

  pm_bin = "$pm_out_dir/pm"
  pkgsvr_bin = "$pkgsvr_out_dir/pkgsvr"
  merkleroot_bin = "$zircon_tools_dir/merkleroot"

  inputs = [
    merkleroot_bin,
    pkgsvr_bin,
    pm_bin,
    system_package_key,
    pkgsvr_index,
  ]

  script = "//build/gn_run_binary.sh"
  args = [
    clang_prefix,
    rebase_path("system_package.py"),
    "--system-manifest",
    rebase_path(final_system_manifest),
    "--system-package-dir",
    rebase_path(system_package_dir),
    "--system-package-key",
    rebase_path(system_package_key),
    "--pm",
    rebase_path(pm_bin),
    "--pkgsvr",
    rebase_path(pkgsvr_bin),
    "--merkleroot",
    rebase_path(merkleroot_bin),
    "--commandline",
    rebase_path(system_package_cmdline),
    "--pkgsvr-index",
    rebase_path(pkgsvr_index),
    "--blob-manifest",
    rebase_path(final_blob_manifest),
  ]
  sources = [
    "system_package.py",
    final_system_manifest,
  ]
  outputs = [
    system_package_cmdline,
    system_package_dir,
    system_package_meta_far,
    final_blob_manifest,
  ]
}

zircon_tool_action("blob.blk") {
  visibility = [ ":*" ]
  tool = "blobfs"
  args = [
    rebase_path(blob_image_path),
    "create",
    "--manifest",
    rebase_path(final_blob_manifest),
    "--manifest",
    rebase_path(packages_blobs_manifest),
  ]
  inputs = [
    system_package_meta_far,
    packages_blobs_manifest,
    final_blob_manifest,
  ]
  outputs = [
    blob_image_path,
  ]
  deps = [
    ":finalize_manifests",
    ":pkgbuilds",
    ":system.pkg",
  ]
}

# Inject fixed kernel command-line arguments maintained in the source tree.
bootdata_cmdline("cmdline") {
  visibility = [ ":*" ]
  inputs = [
    "cmdline.txt",
  ]
}

# Let the build configuration choose some extra fixed command-line arguments.
if (kernel_cmdline_file != "") {
  bootdata_cmdline("extra_cmdline") {
    visibility = [ ":*" ]
    inputs = [
      kernel_cmdline_file,
    ]
  }
}

# Inject generated kernel command-line arguments depending on build artifacts.
bootdata_cmdline("systempkg_cmdline") {
  visibility = [ ":*" ]
  inputs = [
    system_package_cmdline,
  ]
  deps = [
    ":system.pkg",
  ]
}

# Package up the /boot filesystem along with Zircon's kernel bootdata.
# This `bootdata.bin` along with the Zircon kernel is enough to boot.
foreach(board, zircon_boards) {
  bootdata("bootdata-${board}") {
    deps = [
      ":finalize_manifests",
    ]
    inputs = [
      "$zircon_build_dir/${board}-kernel-bootdata.bin",
      final_boot_manifest,
    ]
    boot = true

    deps += [ ":cmdline" ]
    inputs += get_target_outputs(":cmdline")

    if (kernel_cmdline_file != "") {
      deps += [ ":extra_cmdline" ]
      inputs += get_target_outputs(":extra_cmdline")
    }
  }

  bootdata("bootdata-blob-${board}") {
    deps = [
      ":bootdata-${board}",
      ":systempkg_cmdline",
    ]

    inputs = []
    foreach(label, deps) {
      inputs += get_target_outputs(label)
    }
  }
}

# data.blk creates an empty but initialized minfs data partition. The partition
# is included in fvm.data.sparse.blk.
zircon_tool_action("data.blk") {
  tool = "minfs"

  sized_path = rebase_path(data_image_path)
  sized_path = "${sized_path}@${data_image_size}"

  args = [
    sized_path,
    "create",
  ]
  outputs = [
    data_image_path,
  ]
}

# fvm.blk creates a non-sparse FVM partition image containing the blob
# partition produced by blob.blk. fvm.blk is primarily invoked and used by
# the qemu run, via `fx run-fvm`.
zircon_tool_action("fvm.blk") {
  visibility = [ ":*" ]
  tool = "fvm"
  inputs = [
    blob_image_path,
  ]
  deps = [
    ":blob.blk",
  ]

  args = [
    rebase_path(fvm_image_path),
    "create",
    "--blob",
    rebase_path(blob_image_path),
  ]
  outputs = [
    fvm_image_path,
  ]
}

# Convert fvm.blk into a Qemu Copy on Write compressed image. This provides a
# runtime-mountable qemu disk image that is significantly smaller than a raw FVM
# partition image, but not as small as a compressed sparse FVM image.
action("fvm.blk.qcow2") {
  visibility = [ ":*" ]
  script = "//buildtools/${host_platform}/qemu/bin/qemu-img"

  inputs = [
    fvm_image_path,
  ]

  fvm_qcow2_image_path = fvm_image_path + ".qcow2"
  outputs = [
    fvm_qcow2_image_path,
  ]

  deps = [
    ":fvm.blk",
  ]

  args = [
    "convert",
    "-f",
    "raw",
    "-O",
    "qcow2",
    "-c",
    rebase_path(fvm_image_path),
    rebase_path(fvm_qcow2_image_path),
  ]
}

# This packs (compressed) fvm.blk into BOOTDATA_RAMDISK format,
# used by the netboot-* targets below.
bootdata_ramdisk("bootdata-fvm") {
  visibility = [ ":*" ]
  deps = [
    ":fvm.blk",
  ]
  inputs = []
  foreach(label, deps) {
    inputs += get_target_outputs(label)
  }
}

# fvm.sparse.blk creates a sparse FVM partition image containing the blob
# partition produced by blob.blk.  fvm.sparse.blk is primarily invoked and
# used by the paver boot, via `fx boot-paver`.
zircon_tool_action("fvm.sparse.blk") {
  visibility = [ ":*" ]
  tool = "fvm"
  inputs = [
    blob_image_path,
  ]
  deps = [
    ":blob.blk",
  ]
  args = [
    rebase_path(fvm_sparse_image_path),
    "sparse",
    "--compress",
    "lz4",
    "--blob",
    rebase_path(blob_image_path),
  ]
  outputs = [
    fvm_sparse_image_path,
  ]
}

# fmv.data.sparse.blk is an FVM image containing only data.blk. It is
# used to pave new data partitions to a device.
zircon_tool_action("fvm.data.sparse.blk") {
  visibility = [ ":*" ]
  tool = "fvm"
  inputs = [
    data_image_path,
  ]
  deps = [
    ":data.blk",
  ]
  args = [
    rebase_path(fvm_data_sparse_image_path),
    "sparse",
    "--compress",
    "lz4",
    "--data",
    rebase_path(data_image_path),
  ]
  outputs = [
    fvm_data_sparse_image_path,
  ]
}

# Build a "kernel partition" target for ChromeOS targets.
#
# Parameters
#
#   deps (required)
#     Must be bootdata labels defined earlier in the file.
#
template("vboot") {
  output_name = "${target_name}.vboot"
  action(output_name) {
    futility_label = "//garnet/tools/vboot_reference:futility($host_toolchain)"
    futility_out_dir = get_label_info(futility_label, "root_out_dir")
    futility_bin = "$futility_out_dir/futility"
    deps = [
      futility_label,
    ]

    vboot_dir = "//third_party/vboot_reference"
    kernel_keyblock = "$vboot_dir/tests/devkeys/kernel.keyblock"
    private_keyblock = "$vboot_dir/tests/devkeys/kernel_data_key.vbprivk"
    inputs = [
      futility_bin,
      kernel_keyblock,
      private_keyblock,
    ]

    bootdata_bins = []
    foreach(bootdata_label, invoker.deps) {
      bootdata_bins += get_target_outputs(bootdata_label)
    }
    inputs += bootdata_bins
    deps += invoker.deps

    bootdata_bin = bootdata_bins[0]
    assert([ bootdata_bin ] == bootdata_bins)

    zircon_bin = "${zircon_build_dir}/zircon.bin"
    inputs += [ zircon_bin ]

    output = "$images_dir/$output_name"
    outputs = [
      output,
    ]

    script = "//build/gn_run_binary.sh"
    args = [
      clang_prefix,
      rebase_path(futility_bin),
      "vbutil_kernel",
      "--pack",
      rebase_path(output),
      "--keyblock",
      rebase_path(kernel_keyblock),
      "--signprivate",
      rebase_path(private_keyblock),
      "--bootloader",
      rebase_path(bootdata_bin),
      "--vmlinuz",
      rebase_path(zircon_bin),
      "--version",
      "1",
      "--flags",
      "0x2",
    ]
  }
}

# Build a "EFI System Partition" target for EFI targets.
#
# Parameters
#
#   deps (optional)
#     Must be bootdata labels defined earlier in the file.
#
#   zircon_bin (optional)
#     A zircon kernel
#
#   zedboot (optional)
#     A Zedboot bootdata label defined earlier in the file.
#
#   cmdline (optional)
#     A bootloader (Gigaboot) cmdline file to include in the EFI root.
#
template("esp") {
  output_name = "${target_name}.esp.blk"
  action(output_name) {
    make_efi_label = "//garnet/go/src/make-efi:host($host_toolchain)"
    deps = [
      make_efi_label,
    ]

    mkfs_msdosfs_bin = "$zircon_tools_dir/mkfs-msdosfs"

    make_efi_out_dir = get_label_info(make_efi_label, "root_out_dir")
    make_efi_bin = "$make_efi_out_dir/make-efi"

    efi_image_path = "$images_dir/$output_name"

    inputs = [
      mkfs_msdosfs_bin,
    ]

    script = "//build/gn_run_binary.sh"
    args = [
      clang_prefix,
      rebase_path(make_efi_bin),
      "--output",
      rebase_path(efi_image_path),
      "--mkfs",
      rebase_path(mkfs_msdosfs_bin),
    ]

    if (defined(invoker.zircon_bin)) {
      args += [
        "--zircon",
        rebase_path(invoker.zircon_bin),
      ]
    }

    if (defined(invoker.deps)) {
      bootdata_bins = []
      foreach(bootdata_label, invoker.deps) {
        bootdata_bins += get_target_outputs(bootdata_label)
      }
      deps += invoker.deps

      bootdata_bin = bootdata_bins[0]
      assert([ bootdata_bin ] == bootdata_bins)

      args += [
        "--bootdata",
        rebase_path(bootdata_bin),
      ]
    }

    if (defined(invoker.zedboot)) {
      zedboot_label = invoker.zedboot
      zedboot_bins = get_target_outputs(zedboot_label)
      zedboot_bin = zedboot_bins[0]
      assert([ zedboot_bin ] == zedboot_bins)
      args += [
        "--zedboot",
        rebase_path(zedboot_bin),
      ]
      deps += [ zedboot_label ]
    }

    if (defined(invoker.cmdline)) {
      args += [
        "--cmdline",
        rebase_path(invoker.cmdline),
      ]
    }

    if (target_cpu == "x64") {
      gigaboot_bin = "${zircon_build_dir}/bootloader/bootx64.efi"
      args += [
        "--efi-bootloader",
        rebase_path(gigaboot_bin),
      ]
      inputs += [ gigaboot_bin ]
    }

    outputs = [
      efi_image_path,
    ]
  }
}

bootdata_cmdline("zedboot_cmdline") {
  visibility = [ ":*" ]
  inputs = [
    "zedboot_config",
  ]
}

# Construct a minimal manifest containing only the few user binaries
# that constitute zedboot, and the libraries they depend on.
# TODO(mcgrathr): This could be made smaller by constraining the drivers
# included, but we don't currently have a good way to determine the
# subset that is useful to Zedboot.
zedboot_manifest = "$root_out_dir/zedboot.manifest"
zedboot_binary_patterns = [
  # These are the core things needed for booting (local and netboot).
  "bin/crashlogger",
  "bin/devmgr",
  "bin/dlog",
  "bin/fshost",
  "bin/netsvc",
  "bin/virtual-console",
  "driver/*",  # Drivers automagically cause devhost to be brought in.

  # These are needed for installer runs.
  "bin/blobfs",
  "bin/install-disk-image",
  "bin/minfs",
  "bin/mount",

  # These are useful for debugging.
  "bin/dd",
  "bin/fixfs",
  "bin/fsck*",
  "bin/gpt",
  "bin/killall",
  "bin/lsblk",
  "bin/lsdev",
  "bin/lsusb",
  "bin/mkfs*",
  "bin/netdump",
  "bin/ping",
  "bin/ps",
  "bin/sh",
  "bin/umount",
]

action("zedboot_manifest") {
  visibility = [ ":*" ]

  script = "finalize_manifests.py"
  inputs = finalize_manifests_extra

  depfile = "$root_out_dir/zedboot_manifest.d"
  build_id_file = "$root_out_dir/zedboot_ids.txt"

  outputs = [
    zedboot_manifest,
    build_id_file,
  ]

  sources = zircon_boot_manifests
  args = []
  foreach(manifest, zircon_boot_manifests) {
    manifest_cwd = get_path_info(rebase_path(manifest), "dir") + "/.."
    args += [
      "--cwd=$manifest_cwd",
      "--manifest=" + rebase_path(manifest),
    ]
  }

  args += [
    "--depfile=" + rebase_path(depfile, root_build_dir),
    "--build-id-file=" + rebase_path(build_id_file, root_build_dir),
    "--output=" + rebase_path(zedboot_manifest, root_build_dir),
  ]

  foreach(pattern, zedboot_binary_patterns) {
    args += [ "--binary=" + pattern ]
  }
}

foreach(board, zircon_boards) {
  # zedboot-data-${board}.bin is a Zircon BOOTDATA file containing the
  # command line and BOOTFS pieces necessary to make Zircon be Zedboot.
  bootdata("zedboot-data-${board}") {
    boot = true
    deps = [
      ":zedboot_cmdline",
      ":zedboot_manifest",
    ]
    inputs = [
      "${zircon_build_dir}/${board}-kernel-bootdata.bin",
    ]
    foreach(dep, deps) {
      dep = get_target_outputs(dep)
      inputs += [ dep[0] ]
    }
  }

  # This packs up a single BOOTDATA container that includes fvm.blk as a
  # RAMDISK image.  This can be used for network booting the full system
  # without using any real storage.  The system decompresses the fvm.blk
  # image into memory and then sees that RAM disk just as if it were a
  # real disk on the device.
  bootdata("netboot-${board}") {
    deps = [
      ":bootdata-blob-${board}",
      ":bootdata-fvm",
    ]
    inputs = []
    foreach(label, deps) {
      inputs += get_target_outputs(label)
    }
  }

  # ChromeOS vboot images.
  vboot("zircon-${board}") {
    deps = [
      ":bootdata-blob-${board}",
    ]
  }

  # arm64 kernels are not valid bootdata, and cannot be used to produce unified
  # kernel+bootdata images such as zedboot-{board}.bin
  if (target_cpu != "arm64") {
    # images/zedboot-${board}.bin combines the kernel image itself with
    # the BOOTDATA bits.  This single file can be booted by Gigaboot.
    bootdata("zedboot-${board}") {
      output_name = "images/$target_name"
      deps = [
        ":zedboot-data-${board}",
      ]
      inputs = [
        "${zircon_build_dir}/zircon.bin",
      ]
      foreach(label, deps) {
        inputs += get_target_outputs(label)
      }
    }
  }

  vboot("zedboot-${board}") {
    deps = [
      ":zedboot-data-${board}",
    ]
  }

  # EFI ESP images.
  esp("local-${board}") {
    if (always_zedboot) {
      cmdline = "efi_zedboot_cmdline"
    } else {
      cmdline = "efi_local_cmdline"
    }
    zircon_bin = "${zircon_build_dir}/zircon.bin"

    # Unified zedboot is not available for arm64
    if (target_cpu != "arm64") {
      zedboot = ":zedboot-${board}"
    }

    deps = [
      ":bootdata-blob-${board}",
    ]
  }

  if (target_cpu != "arm64") {
    esp("zedboot-${board}") {
      cmdline = "efi_zedboot_cmdline"
      zedboot = ":zedboot-${board}"
    }
  }

  # install.blk creates a minfs partition image that includes all of the images
  # required to install a Fuchsia build.
  action("install-${board}.blk") {
    minfs_path = "$zircon_tools_dir/minfs"
    installer_label = "//garnet/bin/installer:install-fuchsia"
    installer_out_dir = get_label_info(installer_label, "root_out_dir")
    installer_path = installer_out_dir + "/install-fuchsia"

    inputs = [
      minfs_path,
      installer_path,
    ]

    # The installer needs all images except for `fvm.blk` (it uses fvm.sparse.blk):
    input_images = [
      "fvm.sparse.blk",
      "fvm.data.sparse.blk",
      "local-${board}.esp.blk",
      "zedboot-${board}.vboot",
      "zircon-${board}.vboot",
    ]

    if (target_cpu != "arm64") {
      input_images += [ "zedboot-${board}.esp.blk" ]
    }

    # Add all of the input images as dependencies
    deps = [
      installer_label,
    ]
    foreach(image, input_images) {
      deps += [ ":${image}" ]
    }

    install_manifest = "$root_build_dir/install_manifest"

    # Produce a manifest of images to be added to the filesystem
    manifest_lines = []
    rebased_installer_path = rebase_path(installer_path, root_build_dir)
    manifest_lines += [ "install-fuchsia=${rebased_installer_path}" ]
    foreach(image, input_images) {
      image_src_path = rebase_path("${images_dir}/${image}", root_build_dir)
      manifest_lines += [ "${image}=${image_src_path}" ]
    }
    write_file(install_manifest, manifest_lines)

    output_image_path = "${images_dir}/${target_name}"
    outputs = [
      output_image_path,
    ]
    sources = [
      "mkminfs.py",
    ]

    script = "//build/gn_run_binary.sh"
    args = [
      clang_prefix,
      rebase_path(sources[0]),
      "--minfs",
      rebase_path(minfs_path),
      "--output",
      rebase_path(output_image_path),
      "--manifest",
      rebase_path(install_manifest),
    ]
  }
}

group("zedboot") {
  deps = []
  foreach(board, zircon_boards) {
    # Unified zedboot is not available for arm64, but we can still build the
    # zedboot-data which is useful if someone wants to construct a zedboot
    # image/disk.
    if (target_cpu == "arm64") {
      deps += [ ":zedboot-data-${board}" ]
    } else {
      deps += [ ":zedboot-${board}" ]
    }
  }
}

group("netboot") {
  deps = []
  foreach(board, zircon_boards) {
    deps += [ ":netboot-${board}" ]
  }
}

group("images") {
  deps = [
    ":blob.blk",
    ":fvm.blk",
    ":fvm.data.sparse.blk",
    ":fvm.sparse.blk",
    "//zircon/public/config:boards",
  ]

  foreach(board, zircon_boards) {
    deps += [
      ":local-${board}.esp.blk",
      ":zedboot-${board}.vboot",
      ":zircon-${board}.vboot",
    ]
    if (target_cpu != "arm64") {
      deps += [ ":zedboot-${board}.esp.blk" ]
    }
  }
}

group("install") {
  deps = []
  foreach(board, zircon_boards) {
    deps += [ ":install-${board}.blk" ]
  }
}

group("default") {
  deps = [ ":images", ":netboot" ] + packages_labels
}
