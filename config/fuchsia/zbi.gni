# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/fuchsia/zircon.gni")

# Template for assembling a Zircon Boot Image file from various inputs.
#
# Parameters
#
#   output_name (optional, default: target_name)
#   output_extension (optional, default: "zbi")
#       [string] These together determine the name of the output file.
#       If `output_name` is omitted, then the name of the target is
#       used.  If `output_extension` is "" then `output_name` is the
#       file name; otherwise, `${output_name}.${output_extension}`;
#       the output file is always under `root_out_dir`.
#
#   complete (optional, default: true)
#       [Boolean] If true, then the output is intended to be a complete ZBI.
#       That is, a single file that can be booted.  This will make the tool
#       verify it has the necessary contents and finalize it appropriately.
#
#   compress (optional, default: true)
#       [Boolean] If true, BOOTFS and RAMDISK payloads will be compressed.
#
#   inputs (optional)
#       [list of files] Input files.  Each can be either a ZBI format
#       file (e.g. from another `zbi` action, or the kernel ZBI), or a
#       manifest file or directory to generate a `BOOTFS` filesystem
#       embedded in the ZBI output.
#
#   cmdline (optional)
#       [list of strings] Kernel command line text.
#
#   cmdline_inputs (optional)
#       [list of files] Input files treated as kernel command line text.
#
#   manifest (optional)
#       [list of string|scope] List of individual manifest entries.
#       Each entry can be a "TARGET=SOURCE" string, or it can be a scope
#       with `sources` and `outputs` in the style of a copy() target:
#       `outputs[0]` is used as `TARGET` (see `gn help source_expansion`).
#
#   ramdisk_inputs (optional)
#       [list of files] Input files treated as raw RAM disk images.
#
#   deps (usually required)
#   visibility (optional)
#   testonly (optional)
#       Same as for any GN `action` target.  `deps` must list labels that
#       produce all the `inputs`, `cmdline_inputs`, and `ramdisk_inputs`
#       that are generated by the build (none are required for inputs that
#       are part of the source tree).
#
# Each of the various kinds of input is optional, but the action will
# fail at build time (not at `gn gen` time) if there are is no input of
# any kind.
template("zbi") {
  if (defined(invoker.output_name)) {
    output_file = invoker.output_name
  } else {
    output_file = target_name
  }

  if (defined(invoker.output_extension)) {
    if (invoker.output_extension != "") {
      output_file += ".${invoker.output_extension}"
    }
  } else {
    output_file += ".zbi"
  }

  output_file = "$root_out_dir/$output_file"

  zircon_tool_action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "visibility",
                             "testonly",
                           ])
    outputs = [
      output_file,
    ]
    depfile = "${output_file}.d"
    inputs = []

    tool = "zbi"
    args = [
      "--output=" + rebase_path(output_file, root_build_dir),
      "--depfile=" + rebase_path(depfile, root_build_dir),
    ]

    if (!defined(invoker.complete) || invoker.complete) {
      args += [ "--complete=" + current_cpu ]
    }

    if (defined(invoker.compress) && !invoker.compress) {
      args += [ "--uncompressed" ]
    }

    if (defined(invoker.inputs)) {
      args += rebase_path(invoker.inputs, root_build_dir)
      inputs += invoker.inputs
    }

    if (defined(invoker.manifest)) {
      foreach(entry, invoker.manifest) {
        if (entry == "$entry") {
          # It's a literal manifest entry string.
          args += [ "--entry=$entry" ]
        } else {
          # It's a manifest entry in the style of a copy() target.
          targets = entry.outputs
          assert(targets == [ targets[0] ],
                 "manifest entry outputs list must have exactly one element")
          foreach(source, entry.sources) {
            inputs += [ source ]
            source_path = rebase_path(source, root_build_dir)
            foreach(target, process_file_template([ source ], targets)) {
              args += [ "--entry=${target}=${source_path}" ]
            }
          }
        }
      }
    }

    if (defined(invoker.ramdisk_inputs)) {
      args += [ "--type=ramdisk" ]
      args += rebase_path(invoker.ramdisk_inputs, root_build_dir)
      inputs += invoker.ramdisk_inputs
    }

    if (defined(invoker.cmdline) || defined(invoker.cmdline_inputs)) {
      args += [ "--type=cmdline" ]
      if (defined(invoker.cmdline)) {
        foreach(cmdline, invoker.cmdline) {
          args += [ "--entry=$cmdline" ]
        }
      }
      if (defined(invoker.cmdline_inputs)) {
        args += rebase_path(invoker.cmdline_inputs, root_build_dir)
        inputs += invoker.cmdline_inputs
      }
    }
  }
}
